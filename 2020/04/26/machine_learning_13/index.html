<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    

    
    <title>의사결정나무 | DataLatte&#39;s IT Blog</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content>
    
    
    <meta name="description" content="Decision tree 배경 의사결정나무의 장점은 해석력이 좋다. 우리가 모델을 만들때 성능이 좋은 것도 중요하지만, 어떻게 사람들한테 메세지를 줄 수 있는가처럼 어떻게 활용할 수 있는가가 더 중요한 경우도 있다. 예측력이 조금 떨어지더라도 이야기로 풀어서 어떠한 근거로 인해 Y는 이렇게 된다는 식으로 풀어서 설명할 수 있다는 의미이다.   결정트리는 매">
<meta property="og:type" content="article">
<meta property="og:title" content="의사결정나무">
<meta property="og:url" content="https://heung-bae-lee.github.io/2020/04/26/machine_learning_13/index.html">
<meta property="og:site_name" content="DataLatte&#39;s IT Blog">
<meta property="og:description" content="Decision tree 배경 의사결정나무의 장점은 해석력이 좋다. 우리가 모델을 만들때 성능이 좋은 것도 중요하지만, 어떻게 사람들한테 메세지를 줄 수 있는가처럼 어떻게 활용할 수 있는가가 더 중요한 경우도 있다. 예측력이 조금 떨어지더라도 이야기로 풀어서 어떠한 근거로 인해 Y는 이렇게 된다는 식으로 풀어서 설명할 수 있다는 의미이다.   결정트리는 매">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://heung-bae-lee.github.io/image/decision_tree_concept.png">
<meta property="og:updated_time" content="2020-04-30T14:32:46.338Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="의사결정나무">
<meta name="twitter:description" content="Decision tree 배경 의사결정나무의 장점은 해석력이 좋다. 우리가 모델을 만들때 성능이 좋은 것도 중요하지만, 어떻게 사람들한테 메세지를 줄 수 있는가처럼 어떻게 활용할 수 있는가가 더 중요한 경우도 있다. 예측력이 조금 떨어지더라도 이야기로 풀어서 어떠한 근거로 인해 Y는 이렇게 된다는 식으로 풀어서 설명할 수 있다는 의미이다.   결정트리는 매">
<meta name="twitter:image" content="https://heung-bae-lee.github.io/image/decision_tree_concept.png">
<meta property="fb:app_id" content="100003222637819">


    <link rel="canonical" href="https://heung-bae-lee.github.io/2020/04/26/machine_learning_13/">

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">
    <link rel="stylesheet" type="text/css" href>
    <link rel="stylesheet" href="https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css">	
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css">
    <link rel="stylesheet" href="/css/style.css">
   
    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154199624-1', 'auto');
ga('send', 'pageview');

</script>

    
    


    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 상단형 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4604833066889492" data-ad-slot="4588503508" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<link rel="alternate" href="/rss2.xml" title="DataLatte's IT Blog" type="application/rss+xml">
</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">DataLatte&#39;s IT Blog using Hexo</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Bayes/">Bayes</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/C-C-자료구조/">C/C++/자료구조</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/CS231n/">CS231n</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Front-end/">Front end</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kaggle/">Kaggle</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/NLP/">NLP</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Python/">Python</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Recommendation-System/">Recommendation System</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Statistics-Mathematical-Statistics/">Statistics - Mathematical Statistics</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/crawling/">crawling</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/data-engineering/">data engineering</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/deep-learning/">deep learning</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/growth-hacking/">growth hacking</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/hexo/">hexo</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/linear-algebra/">linear algebra</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/machine-learning/">machine learning</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/machine-learning/">machine learning</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 상단형 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4604833066889492"
     data-ad-slot="4588503508"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

			    <article id="post-machine_learning_13" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        의사결정나무
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2020/04/26/machine_learning_13/" class="article-date">
            <time datetime="2020-04-25T18:27:27.000Z" itemprop="datePublished">2020-04-26</time>
        </a>
    </div>

		

                
            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="Decision-tree-배경"><a href="#Decision-tree-배경" class="headerlink" title="Decision tree 배경"></a>Decision tree 배경</h1><ul>
<li>의사결정나무의 장점은 해석력이 좋다. 우리가 모델을 만들때 성능이 좋은 것도 중요하지만, 어떻게 사람들한테 메세지를 줄 수 있는가처럼 어떻게 활용할 수 있는가가 더 중요한 경우도 있다. 예측력이 조금 떨어지더라도 이야기로 풀어서 어떠한 근거로 인해 Y는 이렇게 된다는 식으로 풀어서 설명할 수 있다는 의미이다.</li>
</ul>
<ul>
<li>결정트리는 매우 쉽고 유연하게 적용될 수 있는 알고리즘이다. 또한 <code>데이터의 Scaling이나 정규화(normalize) 등의 사전 가공의 영향이 매우 적다. 하지만, 예측 성능을 향상시키기 위해 복잡한 규칙 구조를 거쳐야 하며, 이로 인한 과적합(overfitting)이 발생해 반대로 예측 성능이 저하될 수도 있다는 단점이있다.</code> 이러한 단점이 앙상블 기법에서는 오히려 장점으로 작용한다. 앙상블은 매우 많은 여러개의 예측 성능이 상대적으로 떨어지는 학습 알고리즘을 결합해 확률적 보완과 오류가 발생한 부분에 대한 가중치를 계속 업데이트하면서 예측 성능을 향상시키는데, 결정트리가 좋은 약한 학습기가 되기 때문이다.</li>
</ul>
<ul>
<li>결정 트리(Decision Tree)는 ML 알고리즘 중 직관적으로 이해하기 쉬운 알고리즘이다. <code>데이터에 있는 규칙을 학습을 통해 자동으로 찾아내는 트리(Tree) 기반의 분류 규칙을 만드는 것</code>이다. 따라서, <code>데이터의 어떤 기준을 바탕으로 규칙을 만들어야 가장 효율적인 분류가 될 것인각가 알고리즘의 성능을 크게 좌우</code>한다. 의사결정나무(decision tree)는 여러 가지 규칙을 순차적으로 적용하면서 독립 변수 공간을 분할하는 분류 모형이다. 분류(classification)와 회귀 분석(regression)에 모두 사용될 수 있기 때문에 CART(Classification And Regression Tree)라고도 한다.</li>
</ul>
<p><img src="/image/decision_tree_concept.png" alt="결정 트리"></p>
<ul>
<li>아래 그림은 결정 트리의 구조를 간략하게 나타낸 것이다. 데이터 세트에 feature가 있고 이러한 feature가 결합해 규칙 조건을 만들 때마다 규칙 노드가 만들어지며 새로운 규칙 조검마다 서브 트리(Sub tree)가 생성된다. 하지만 <code>많은 규칙이 있다는 것은 곧 분류를 결정하는 방식이 더욱 복잡해진다는 얘기이고, 이는 곧 과적합(overfitting)으로 이어지기 쉽다. 즉, 트리의 깊이(Depth)가 깊어질수록 결정 트리의 예측 성능이 저할될 가능성이 높아진다는 의미</code>이다.</li>
</ul>
<p><img src="/image/consist_of_decision_tree_node.png" alt="결정 트리 용어 - 01"></p>
<p><img src="/image/consist_of_decision_tree_node_01.png" alt="결정 트리 용어 - 02"></p>
<ul>
<li>결정트리는 다음과 같이 종속변수(반응 변수, target 값)의 자료형에 의해서 다음과 같이 분류될 수 있다. 아래 그림에서 오른쪽 그림이 분류트리이고 왼쪽 그림이 회귀 트리이다.</li>
</ul>
<p><img src="/image/what_kinds_of_decision_tree_for_dependent_variable.png" alt="결정 트리 종류"></p>
<h3 id="Entropy"><a href="#Entropy" class="headerlink" title="Entropy"></a>Entropy</h3><ul>
<li><p>그렇다면, 가능한 적은 결정 노드로 높은 예측 정확도를 가지려면 데이터를 분류할 때 최대한 많은 데이터 세트가 해당 분류에 속할 수 있도록 결정 노드의 규칙이 정해져야 한다. 이를 위해서는 어떻게 트리를 분할(Split)할 것인가가 중요한데 최대한 균일한 데이터 세트를 구성할 수 있도록 분할하는 것이 필요하다.</p>
</li>
<li><p>엔트로피는 섞여있는 상태를 의미한다고 생각하면 이해하기 쉽다. 섞여있는 상태면 엔트로피가 높은 것이고 물리적인 힘을 써서 분리는 해놓은 경우는 엔트로피가 낮은 상태이다. 아래 그림에서 $x$축의 $P+$가 의미하는 것이 노란 곡물이 나올 확률이라고 가정해 보자. $P+$가 0인 상황은 노란 곡물이 없는 상태를 의미하고, 1인 경우는 노란 곡물만 있는 상태일 것이다. 이 때의 엔트로피는 잘 분리되어있기 때문에 0의 값을 갖게된다. 허나 $P+$가 0.5일 경우는 노란곡물이 존재하거나 하지 않을 확률이 각각 절반이기 때문에 엔트로피가 가장 높게 된다.</p>
</li>
</ul>
<p><img src="/image/what_is_entropy.png" alt="Entropy"></p>
<ul>
<li><p>확률론에서의 <code>엔트로피</code> 개념은 <code>확률분포의 모양을 설명하는 특징값이며 확률분포가 가지고 있는 정보의 양을 나타내는 값</code>이기도 하다. 엔트로피는 두 확률분포의 모양이 어떤 관계를 가지는지 혹은 유사한지를 표현하는 데도 쓰인다. 조건부엔트로피는 한 확률분포에 의해 다른 확률분포가 받는 영향을 설명한다. 교차엔트로피와 쿨백-라이블러 발산은 두 확률분포가 얼마나 닮았는지를 나타낸다. 마지막으로 두 확률분포의 독립 및 상관관계를 나타내는 상호정보량에 대해서 설명할 것이다.</p>
</li>
<li><p>$Y\;=\;0$ 또는 $Y\;=\;1$인 두 가지 값을 가지는 확률변수의 확률분포가 다음과 같이 세 종류가 있다고 하자.</p>
<ul>
<li>확률분포 $Y_{1}$ : $P(Y=0)=0.5, P(Y=1)=0.5$</li>
<li>확률분포 $Y_{2}$ : $P(Y=0)=0.8, P(Y=1)=0.2$</li>
<li>확률분포 $Y_{3}$ : $P(Y=0)=1.0, P(Y=0)=0.0$</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(9, 3))</span><br><span class="line">plt.subplot(131)</span><br><span class="line">plt.bar([0, 1], [0.5, 0.5])</span><br><span class="line">plt.xticks([0, 1], [<span class="string">"Y=0"</span>, <span class="string">"Y=1"</span>])</span><br><span class="line">plt.ylim(0, 1.1)</span><br><span class="line">plt.title(<span class="string">"<span class="variable">$Y_1</span>$"</span>)</span><br><span class="line">plt.subplot(132)</span><br><span class="line">plt.bar([0, 1], [0.8, 0.2])</span><br><span class="line">plt.xticks([0, 1], [<span class="string">"Y=0"</span>, <span class="string">"Y=1"</span>])</span><br><span class="line">plt.ylim(0, 1.1)</span><br><span class="line">plt.title(<span class="string">"<span class="variable">$Y_2</span>$"</span>)</span><br><span class="line">plt.subplot(133)</span><br><span class="line">plt.bar([0, 1], [1.0, 0.0])</span><br><span class="line">plt.xticks([0, 1], [<span class="string">"Y=0"</span>, <span class="string">"Y=1"</span>])</span><br><span class="line">plt.ylim(0, 1.1)</span><br><span class="line">plt.title(<span class="string">"<span class="variable">$Y_3</span>$"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/image/probability_distribution_ploting.png" alt="확률분포 그래프"></p>
<ul>
<li><p>베이지안 관점에서 위 확률분포는 다음과 같은 정보를 나타낸다.</p>
<ul>
<li>확률분포 $Y_{1}$은 $y$값에 대해 아무것도 모르는 상태</li>
<li>확률분포 $Y_{2}$은 $y$값이 0이라고 믿지만 아닐 가능성도 있다는 것을 아는 상태</li>
<li>확률분포 $Y_{2}$은 $y$값이 0이라고 100% 확신하는 상태</li>
</ul>
</li>
<li><p>확률 분포가 가지는 이러한 차이를 하나의 숫자로 나타낸 것이 바로 엔트로피이다.</p>
</li>
</ul>
<h3 id="Entropy-정의"><a href="#Entropy-정의" class="headerlink" title="Entropy 정의"></a>Entropy 정의</h3><ul>
<li><p>엔트로피(Entropy)는 <code>확률분포가 가지는 정보의 확신도 혹은 정보량을 수치로 표현한 것</code>이다. 확률분포에서 특정한 값이 나올 확률이 높아지고 나머지 값의 확률은 낮아진다면 엔트로피가 작아진다. 반대로 여러가지 값이 나올 확률이 대부분 비슷한 경우에는 엔트로피가 높아진다. 엔트로피는 확률분포의 모양이 어떤지를 나타내는 특성값 중 하나로 볼 수도 있다. <code>확률 또는 확률밀도가 특정값에 몰려있으면 엔트로피가 작다고 하고 반대로 여러가지 값에 골고루 퍼져 있다면 엔트로피가 크다고 한다.</code> 확률분포의 엔트로피는 물리학의 엔트로피 용어를 빌려온 것이다. 물리학에서는 물질의 상태가 분산되는 정도를 엔트로피로 정의한다. 물체의 상태가 여러가지로 고루 분산되어 있으면 엔트로피가 높고 특정한 하나의 상태로 몰려있으면 엔트로피가 낮다. 수학적으로 엔트로피는 확률분포함수를 입력으로 받아 숫자를 출력하는 범함수(functional)로 정의한다.</p>
</li>
<li><p>확률변수 $Y$가 카테고리분포와 같은 이산확률변수이면 다음처럼 정의한다. 이 식에서 $K$는 $X$가 가질 수 있는 클래스의 수이고 p(y)는 확률질량함수이다. 확률의 로그값이 항상 음수이므로 음수 기호를 붙여서 양수로 만들었다.</p>
</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y] = -\sum_{k=1}^K p(y_k) \log_2 p(y_k) \end{align}</script><ul>
<li>확률변수 $Y$가 연속확률변수이면 다음처럼 정의한다. 아래 수식에서 $p(y)$는 pdf이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y] = -\int_{-\infty}^{\infty} p(y) \log_2 p(y) \; dy \end{align}</script><ul>
<li>로그의 밑(base)이 2로 정의된 것은 정보통신과 관련을 가지는 역사적인 이유 때문이다. 엔트로피 계산에서 $p(y)\;=\;0$인 경우에는 로그값이 정의되지 않으므로 다음과 같은 극한값을 사용한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \lim_{p\rightarrow 0} \; p\log_2{p} = 0 \end{align}</script><ul>
<li>이 값은 로피탈의 정리에서 구할 수 있다. 위에서 예를 든 $Y_{1}, Y_{2}, Y_{3}$ 3개의 이산확률분포에 대해 엔트로피를 구하면 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y_1] = -\dfrac{1}{2} \log_2 \dfrac{1}{2} -\dfrac{1}{2} \log_2 \dfrac{1}{2} = 1 \end{align}</script><script type="math/tex; mode=display">\begin{align} H[Y_2] = -\dfrac{8}{10} \log_2 \dfrac{8}{10} -\dfrac{2}{10} \log_2 \dfrac{2}{10} \approx 0.72 \end{align}</script><script type="math/tex; mode=display">\begin{align} H[Y_3] = -1 \log_2 1 -0 \log_2 0 = 0 \end{align}</script><ul>
<li>다음은 Numpy로 엔트로피를 계산한 결과다. 확률값이 0일 때는 가장 작은 값인 <code>eps</code>를 대신 사용한다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.5 * np.log2(0.5) - 0.5 * np.log2(0.5)</span><br></pre></td></tr></table></figure>
<h5 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.8 * np.log2(0.8) - 0.2 * np.log2(0.2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-1"><a href="#결과-1" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.7219280948873623</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eps = np.finfo(<span class="built_in">float</span>).eps</span><br><span class="line">-1 * np.log2(1) - eps * np.log2(eps)</span><br></pre></td></tr></table></figure>
<h5 id="결과-2"><a href="#결과-2" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1546319456101628e-14</span><br></pre></td></tr></table></figure>
<blockquote>
<p>연습문제) 베르누이분포에서 확률값 $P(Y=1)$은 0부터 1까지의 값을 가질 수 있다. 각각의 값에 대해 엔트로피를 계산하여 가로축이 P(Y=1)이고 세로축이 H(Y)인 그래프를 그려라.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.font_manager as fm</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/Library/Fonts/NanumGothic.ttf'</span></span><br><span class="line">font_name = fm.FontProperties(fname=path, size=50).get_name()</span><br><span class="line">plt.rc(<span class="string">'font'</span>, family=font_name)</span><br><span class="line"></span><br><span class="line">P_Y = np.linspace(0, 1, 100)</span><br><span class="line">ls=[]</span><br><span class="line"><span class="keyword">for</span> p_y <span class="keyword">in</span> P_Y:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_y != 0) and (1-p_y != 0):</span><br><span class="line">        ls.append(- p_y * np.log2(p_y) -(1 - p_y) * np.log2(1-p_y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_y == 0) and (1 - p_y == 1):</span><br><span class="line">        p_y = np.finfo(<span class="built_in">float</span>).eps</span><br><span class="line">        ls.append(- p_y * np.log2(p_y) -(1 - p_y) * np.log2(1-p_y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_y == 1) and (1 - p_y == 0):</span><br><span class="line">        ls.append(- p_y * np.log2(p_y) -(np.finfo(<span class="built_in">float</span>).eps) * np.log2(np.finfo(<span class="built_in">float</span>).eps))</span><br><span class="line"></span><br><span class="line">plt.plot(P_Y, ls, <span class="string">"-"</span>, label=<span class="string">"엔트로피"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"엔트로피"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"베르누이 분포의 모수"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/image/bernoulli_distribution_parameters_entropy.png" alt="베르누이 분포의 모수에 따른 엔트로피"></p>
<p><img src="/image/ENTROPY_dost_plot.png" alt="엔트로피의 직관적 해석"></p>
<blockquote>
<p>다음 확률분포의 엔트로피를 계산하라.</p>
</blockquote>
<script type="math/tex; mode=display">\begin{align} H[Y] = -\sum_{k=1}^K p(y_k) \log_2 p(y_k) \end{align}</script><ul>
<li>엔트로피의 정의에따라 풀면 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">(1) P(Y=0)=\dfrac{1}{8}, P(Y=1)=\dfrac{1}{8}, P(Y=2)=\dfrac{1}{4}, P(Y=3)=\dfrac{1}{2}</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 1/8 * np.log2(1/8) -(1/8) * np.log2(1/8) -(2/8) * np.log2(2/8) -(4/8) * np.log2(4/8)</span><br></pre></td></tr></table></figure>
<h5 id="결과-3"><a href="#결과-3" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.75</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">(2) P(Y=0)=1, P(Y=1)=0, P(Y=2)=0, P(Y=3)=0</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 1 * np.log2(1) -(np.finfo(<span class="built_in">float</span>).eps) * np.log2(np.finfo(<span class="built_in">float</span>).eps) -(np.finfo(<span class="built_in">float</span>).eps) * np.log2(np.finfo(<span class="built_in">float</span>).eps) -(np.finfo(<span class="built_in">float</span>).eps) * np.log2(np.finfo(<span class="built_in">float</span>).eps)</span><br></pre></td></tr></table></figure>
<h5 id="결과-4"><a href="#결과-4" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4638958368304884e-14</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">(3) P(Y=0)=\dfrac{1}{4}, P(Y=1)=\dfrac{1}{4}, P(Y=2)=\dfrac{1}{4}, P(Y=3)=\dfrac{1}{4}</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 1/4 * np.log2(1/4) -(1/4) * np.log2(1/4) -(1/4) * np.log2(1/4) -(1/4) * np.log2(1/4)</span><br></pre></td></tr></table></figure>
<h5 id="결과-5"><a href="#결과-5" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0</span><br></pre></td></tr></table></figure>
<h3 id="엔트로피의-성질"><a href="#엔트로피의-성질" class="headerlink" title="엔트로피의 성질"></a>엔트로피의 성질</h3><ul>
<li>확률변수가 결정론적이면 확률분포에서 특정한 하나의 값이 나올 확률이 1이다. 이 때 엔트로피는 0이 되고 이 값은 엔트로피가 가질 수 있는 최솟값이다. 반대로 엔트로피의 최대값은 이산 확률변수의 클래스의 갯수에 따라 달라진다. 만약 이산확률분포가 가질 수 있는 값이 $2^{K}$개면 엔트로피의 최대값은 각 값에 대한 확률이 모두 같은 값인 $\frac{1}/{2^{K}}$이다. 엔트로피의 값은 아래의 수식과 같을 것이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H = -2^K \cdot \frac{1}{2^K}\log_2\dfrac{1}{2^K} = K \end{align}</script><h3 id="엔트로피의-추정"><a href="#엔트로피의-추정" class="headerlink" title="엔트로피의 추정"></a>엔트로피의 추정</h3><ul>
<li>이론적인 확률밀도함수가 없고 실제 데이터가 주어진 경우에는 데이터에서 확률질량함수를 추정한 후, 이를 기반으로 엔트로피를 계산한다. 예를 들어 데이터가 모두 80개가 있고 그 중 $Y=0$인 데이터가 40개, $Y=1$ 데이터가 40개 있는 경우는 엔트로피가 1이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} P(y=0) = \dfrac{40}{80} = \dfrac{1}{2} \end{align}</script><script type="math/tex; mode=display">\begin{align} P(y=1) = \dfrac{40}{80} = \dfrac{1}{2} \end{align}</script><script type="math/tex; mode=display">\begin{align} H[Y] = -\dfrac{1}{2}\log_2\left(\dfrac{1}{2}\right) -\dfrac{1}{2}\log_2\left(\dfrac{1}{2}\right) = \dfrac{1}{2} + \dfrac{1}{2}  = 1 \end{align}</script><ul>
<li>Scipy의 stats 서브패키즈는 엔트로피를 구하는 <code>entropy</code>함수를 제공한다. <code>base</code>인수값은 2가 되어야 한다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = [0.5, 0.5]</span><br><span class="line">sp.stats.entropy(p, base=2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-6"><a href="#결과-6" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>연습 문제)</p>
</blockquote>
<ul>
<li>(1) 데이터가 모두 60개가 있고 그 중 $Y=0$인 데이터가 20개, $Y=1$인 데이터가 40개 있는 경우의 엔트로피를 계산하라.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = [1/3, 2/3]</span><br><span class="line">sp.stats.entropy(p, base=2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-7"><a href="#결과-7" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.9182958340544894</span><br></pre></td></tr></table></figure>
<ul>
<li>(2) 데이터가 모두 40개가 있고 그 중 $Y=0$인 데이터가 30개, $Y=1$인 데이터가 10개 있는 경우의 엔트로피를 계산하라.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = [3/4, 1/4]</span><br><span class="line">sp.stats.entropy(p, base=2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-8"><a href="#결과-8" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.8112781244591328</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = [1, 0]</span><br><span class="line">sp.stats.entropy(p, base=2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-9"><a href="#결과-9" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br></pre></td></tr></table></figure>
<h3 id="가변길이-인코딩"><a href="#가변길이-인코딩" class="headerlink" title="가변길이 인코딩"></a>가변길이 인코딩</h3><ul>
<li>엔트로피는 원래 통신 분야에서 데이터가 가지고 있는 정보량을 계산하기 위해 고안되었다. 예를 들어 4개의 글자 A, B, C, D로 씌여진 다음과 같은 문서가 있다고 하자.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N = 200</span><br><span class="line">p = [1/2, 1/4, 1/8, 1/8]</span><br><span class="line">doc0 = list(<span class="string">""</span>.join([int(N * p[i]) * c <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(<span class="string">"ABCD"</span>)]))</span><br><span class="line">np.random.shuffle(doc0)</span><br><span class="line">doc = <span class="string">""</span>.join(doc0)</span><br><span class="line">doc</span><br></pre></td></tr></table></figure>
<h5 id="결과-10"><a href="#결과-10" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'BDABABACBABBAACADAADAAADAAAAAABBAABADAAAAABBACAABACBBACDBAAACBCABBAABAAAAADDBABCBDBBDDBAABBBADCACAADAADCABADCAAAAACADBAABABCBAACAAABCDAADDCCCAAABABBDACACAAAAAABABBADABBABDBADBACAABDCAAABAAABACCDABAABA'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>이 문서를 0과 1로 이루어진 이진수로 변환해야 하면 보통 다음처럼 인코딩한다.</p>
<ul>
<li>A=”00”</li>
<li>A=”01”</li>
<li>A=”10”</li>
<li>A=”11”</li>
</ul>
</li>
<li><p>이렇게 인코딩을 하면 200글자로 이루어진 문서는 이진수 400개가 된다.</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">encoder = &#123;<span class="string">"A"</span>: <span class="string">"00"</span>, <span class="string">"B"</span>: <span class="string">"01"</span>, <span class="string">"C"</span>: <span class="string">"10"</span>, <span class="string">"D"</span>: <span class="string">"11"</span>&#125;</span><br><span class="line">encoded_doc = <span class="string">""</span>.join([encoder[c] <span class="keyword">for</span> c <span class="keyword">in</span> doc])</span><br><span class="line">encoded_doc</span><br></pre></td></tr></table></figure>
<h5 id="결과-11"><a href="#결과-11" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'0111000100010010010001010000100011000011000000110000000000000101000001001100000000000101001000000100100101001011010000001001100001010000010000000000111101000110011101011111010000010101001110001000001100001110000100111000000000001000110100000100011001000010000000011011000011111010100000000100010111001000100000000000000100010100110001010001110100110100100000011110000000010000000100101011000100000100'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(encoded_doc)</span><br></pre></td></tr></table></figure>
<h5 id="결과-12"><a href="#결과-12" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure>
<ul>
<li>그런데 이진수로 변환할 때 더 글자수를 줄일 수 있는 방법이 있다. 우선 위 글자의 분포를 조사하자.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(list(doc), order=<span class="string">"ABCD"</span>)</span><br><span class="line">plt.title(<span class="string">"글자수의 분포"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/image/count_plot_with_characters_count.png" alt="글자수의 분포"></p>
<ul>
<li>글자수의 분포가 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} P(Y=A)=\dfrac{1}{2}, P(Y=B)=\dfrac{1}{4}, P(Y=C)=\dfrac{1}{8}, P(Y=D)=\dfrac{1}{8} \end{align}</script><ul>
<li><p>지프의 법칙(Zipf’s law)에 따르면 이러한 분포는 현실의 글자 빈도수에서도 흔히 나타난다. 확률분포가 위와 같을 때는 다음처럼 인코딩하면 인코딩된 후의 이진수 수를 줄일 수 있다.</p>
<ul>
<li>A=”0”</li>
<li>B=”10”</li>
<li>C=”110”</li>
<li>D=”111”</li>
</ul>
</li>
<li><p>이 방법은 글자마다 인코딩하는 이진수의 숫자가 다르기 때문에 가변길이 인코딩(variable length encoding)이라고 한다. 가장 많이 출현하는 ‘A’는 두 글자가 아닌 한 글자이므로 인코딩 후의 이진수 수가 감소한다. 반대로 ‘C’, ‘D’는 이진수의 수가 3개로 많지만 글자의 빈도가 적어서 영향이 적다.</p>
</li>
</ul>
<ul>
<li>만약 문서의 분포가 위에서 가정한 분포와 정확하게 같다면 인코딩된 이진수의 숫자는 다음 계산에서 350개가 됨을 알 수 있다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \left(200 \times \dfrac{1}{2}\right) \cdot 1 + \left(200 \times \dfrac{1}{4}\right) \cdot 2 + \left(200 \times \dfrac{1}{8}\right) \cdot 3 + \left(200 \times \dfrac{1}{8}\right) \cdot 3 = 350 \end{align}</script><ul>
<li>따라서 알파벳 한 글자를 인코딩하는데 필요한 평균 비트(bit)수는 $350 \div 200 = 1.75$이고 이 값은 확률변수의 엔트로피 값과 같다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H = -\dfrac{1}{2}\log_2\dfrac{1}{2} -\dfrac{1}{4}\log_2\dfrac{1}{4} -\dfrac{2}{8}\log_2\dfrac{1}{8} = 1.75 \end{align}</script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vl_encoder = &#123;<span class="string">"A"</span>: <span class="string">"0"</span>, <span class="string">"B"</span>: <span class="string">"10"</span>, <span class="string">"C"</span>: <span class="string">"110"</span>, <span class="string">"D"</span>: <span class="string">"111"</span>&#125;</span><br><span class="line">vl_encoded_doc = <span class="string">""</span>.join([vl_encoder[c] <span class="keyword">for</span> c <span class="keyword">in</span> doc])</span><br><span class="line">vl_encoded_doc</span><br></pre></td></tr></table></figure>
<h5 id="결과-13"><a href="#결과-13" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'10111010010011010010100011001110011100011100000010100010011100000101001100010011010100110111100001101011001010001000000111111100101101011110101111111000101010011111001100011100111110010011111000000110011110001001011010001100001011011100111111110110110000100101011101100110000000100101001110101001011110011110011000101111100001000010011011011101000100'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(vl_encoded_doc)</span><br></pre></td></tr></table></figure>
<h5 id="결과-14"><a href="#결과-14" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">350</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.stats.entropy([1/2, 1/4, 1/8, 1/8], base=2)</span><br></pre></td></tr></table></figure>
<h5 id="결과-15"><a href="#결과-15" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.75</span><br></pre></td></tr></table></figure>
<h3 id="지니-불순도"><a href="#지니-불순도" class="headerlink" title="지니 불순도"></a>지니 불순도</h3><ul>
<li>엔트로피와 유사한 개념으로 지니불순도(Gini impurity)라는 것이 있다. 지니불순도는 엔트로피처럼 확률분포가 어느쪽에 치우쳐져있는가를 재는 척도지만 로그를 사용하지 않으므로 계산량이 더 적어 엔트로피 대용으로 많이 사용된다. 경젠학에서도 사용되지만 지니계수(Gini coefficient)와는 다른 개념이라는 점에 주의해야 한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} G[Y] = \sum_{k=1}^K P(y_k) (1 - P(y_k)) \end{align}</script><ul>
<li>다음 그림은 값이 두 개인 이산확률분포에서 지니불순도와 엔트로피를 비교한 결과이다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P0 = np.linspace(0.001, 1 - 0.001, 1000)</span><br><span class="line">P1 = 1 - P0</span><br><span class="line">H = - P0 * np.log2(P0) - P1 * np.log2(P1)</span><br><span class="line">G = 2 * (P0 * (1 - P0) + P1 * (1 - P1))</span><br><span class="line"></span><br><span class="line">plt.plot(P1, H, <span class="string">"-"</span>, label=<span class="string">"엔트로피"</span>)</span><br><span class="line">plt.plot(P1, G, <span class="string">"--"</span>, label=<span class="string">"지니불순도"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">"P(Y=1)"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/image/difference_with_Gini_and_entropy.png" alt="엔트로피와 지니 불순도 비교"></p>
<h3 id="엔트로피-최대화"><a href="#엔트로피-최대화" class="headerlink" title="엔트로피 최대화"></a>엔트로피 최대화</h3><ul>
<li><p>기대값 $0$, 분산 $\sigma^{2}$이 주어졌을 때 엔트로피 $\text{H}[p(x)]$를 가장 크게 만드는 확률밀도함수 $p(x)$는 정규분포가 된다. 이는 아래와 같이 증명한다. 우선 확률 밀도함수가 지켜야 할 제한조건은 다음과 같다.</p>
</li>
<li><p>(1) 확률밀도함수의 총면적은 1</p>
</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \int_{-\infty}^{\infty} p(x) dx = 1 \end{align}</script><ul>
<li>(2) 기댓값(평균)은 0</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \int_{-\infty}^{\infty} xp(x) dx = 0 \end{align}</script><ul>
<li>(3) 분산은 $\sigma^{2}$</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \int_{-\infty}^{\infty} x^2 p(x) dx = \sigma^2 \end{align}</script><ul>
<li>최대화할 목적범함수(objective functional)은 엔트로피이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \text{H}[p(x)] = -\int_{-\infty}^{\infty} p(x)\log p(x) dx \end{align}</script><ul>
<li>라그랑주 승수법으로 제한조건을 추가하면 다음과 같아진다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \begin{aligned} \text{H}[p(x)] &= -\int_{-\infty}^{\infty} p(x)\log p(x) dx + \lambda_1 \left( \int_{-\infty}^{\infty} p(x) dx - 1 \right) \\ & + \lambda_2 \left( \int_{-\infty}^{\infty} xp(x) dx\right) + \lambda_3 \left( \int_{-\infty}^{\infty} x^2 p(x) dx - \sigma^2 \right) \\ &= \int_{-\infty}^{\infty} \left(-p(x)\log p(x) + \lambda_1 p(x) + \lambda_2 xp(x) + \lambda_3 x^2p(x) - \lambda_1 - \lambda_3 \sigma^2 \right) dx \end{aligned} \end{align}</script><ul>
<li>변분법에서 도함수는 다음과 같이 계산된다.</li>
</ul>
<p><a href="https://datascienceschool.net/view-notebook/006a077ee4964eb58c6b08b213126f8f/" target="_blank" rel="noopener">참고 : 변분법</a></p>
<script type="math/tex; mode=display">\begin{align} \dfrac{\delta H}{\delta p(x)} = -\log p(x) - 1 + \lambda_1 + \lambda_2 x + \lambda_3 x^2 = 0 \end{align}</script><ul>
<li>따라서 확률밀도함수의 형태는 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} p(x) = \exp \left( - 1 + \lambda_1 + \lambda_2 x + \lambda_3 x^2 \right) \end{align}</script><ul>
<li>적분을 통해 위 형태의 확률밀도함수의 면적, 기대값, 분산을 계산하고 주어진 제한조건을 만족하도록 연립방정식을 풀면 라그랑주 승수를 다음처럼 구할 수 있다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} \begin{aligned} \lambda_1 &= 1-\dfrac{1}{2} \log{2\pi\sigma^2} \\ \lambda_2 &= 0 \\ \lambda_3 &= -\dfrac{1}{2\sigma^2} \\ \end{aligned} \end{align}</script><ul>
<li>이 값을 대입하면 정규분포라는 것을 알 수 있다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} p(x) = \dfrac{1}{\sqrt{2\pi\sigma^2}} \exp \left( -\dfrac{x^2}{2\sigma^2} \right) \end{align}</script><ul>
<li>따라서 정규분포는 기댓값과 표준편차를 알고있는 확률분포 중에서 가장 엔트로피가 크고 따라서 가장 정보가 적은 확률분포이다. <code>정규분포는 베이즈 추정에 있어서 사실상의 무정보 사전확률분포로 사용되는 경우가 많다.</code></li>
</ul>
<h3 id="의사결정나무를-사용한-분류예측"><a href="#의사결정나무를-사용한-분류예측" class="headerlink" title="의사결정나무를 사용한 분류예측"></a>의사결정나무를 사용한 분류예측</h3><ul>
<li>의사결정나무에 전체 트레이닝 데이터를 모두 적용해 보면 각 데이터는 특정한 노드를 타고 내려가게 된다. 각 노드는 그 노드를 선택한 데이터 집합을 갖는다. 이 때 노드에 속한 데이터의 클래스의 비율을 구하여 이를 그 노드의 조건부 확률분포 $P(Y\;=\;k|X)_{node}$라고 정의한다.</li>
</ul>
<script type="math/tex; mode=display">P(Y=k|X)_{\text{node}} \approx \dfrac{N_{\text{node},k}}{N_{\text{node}}}</script><ul>
<li>테스트 데이터 $X_{test}$의 클래스를 예측할 때는 가장 상위의 노드부터 분류 규칙을 차례대로 적용하여 마지막에 도달하는 노드의 조건부 확률 분포를 이용하여 클래스를 예측한다.</li>
</ul>
<script type="math/tex; mode=display">\hat{Y} = \text{arg}\max_k P(Y=k|X_{\text{test}})_{\text{last node}}</script><h3 id="분류-규칙을-정하는-방법"><a href="#분류-규칙을-정하는-방법" class="headerlink" title="분류 규칙을 정하는 방법"></a>분류 규칙을 정하는 방법</h3><ul>
<li>분류 규칙을 정하는 방법은 부모 노드와 자식 노드간의 엔트로피를 가장 낮게 만드는 최상의 독립 변수와 기준값을 찾는 것이다. 이러한 기준을 정량화한 것이 정보획득량(Information Gain)이다. 기본적으로 모든 독립변수와 모든 가능한 기준값에 대해 정보획득량을 구하여 가장 정보획들량이 큰 독립 변수와 기준값을 선택한다.</li>
</ul>
<h3 id="Information-Gain"><a href="#Information-Gain" class="headerlink" title="Information Gain"></a>Information Gain</h3><ul>
<li><p>데이터 세트의 균일도는 데이터를 구분하는 데 필요한 정보의 양에 영향을 미친다. 결정 노드는 정보 균일도가 높은 데이터 세트를 먼저 선택할 수 있도록 규칙 조건을 만든다. 즉, 정보 균일도가 데이터 세트로 쪼개질 수 있도록 조건을 찾아 서브 데이터 세트를 만들고, 다시 이 서브 데이터 세트에서 균일도가 높은 자식 데이터 세트로 쪼개는 방식을 자식 트로 내려가면서 반복하는 방식으로 데이터 값을 예측하게 된다. 이러한 정보의 균일도를 측정하는 대표적인 방법은 엔트로피를 이용한  Information Gain과 Gini 계수가 있다. 즉, <code>(이전 엔트로피 - 이후 엔트로피)의 차가 많이 나는 규칙부터 실행하여 균일도를 높이는 방식</code>이다. 규칙노드를 통해 이전 엔트로피와의 차이가 클수록 유의미한 규칙이 될 것이다.</p>
</li>
<li><p>정보획득량(Information Gain)는 $X$라는 조건에 의해 확률 변수 $Y$의 엔트로피가 얼마나 감소하였는가를 나타내는 값이다. 다음처럼 $Y$의 엔트로피에서 $X$에 대한 $Y$의 조건부 엔트로피를 뺀 값으로 정의된다.</p>
</li>
</ul>
<script type="math/tex; mode=display">IG[Y,X] = H[Y] - H[Y|X]</script><p><img src="/image/information_Gain_concept.png" alt="Information Gain의 개념"></p>
<h3 id="결합-엔트로피"><a href="#결합-엔트로피" class="headerlink" title="결합 엔트로피"></a>결합 엔트로피</h3><ul>
<li>결합엔트로피(joint entropy)는 결합확률분포를 사용하여 정의한 엔트로피를 말한다. 이산 확률변수 $X,\;Y$에 대해 결합엔트로피는 다음 처럼 정의한다. 아래 식에서 $K_{X}, K_{Y}$는 각각 $X$와 $Y$가 가질 수 있는 값의 개수이고, $p$는 결합 확률질량함수이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[X, Y] = - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} \,p(x_i, y_j) \log_2 p(x_i, y_j) \end{align}</script><ul>
<li>연속확률변수 $X,\;Y$에 대한 결합엔트로피는 다음처럼 정의한다. 아래 식에서 $p$는 결합 확률밀도함수이다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[X, Y] = - \int_{x} \int_{y} \,p(x, y) \log_2 p(x, y)  \; dxdy \end{align}</script><ul>
<li>결합엔트로피도 결합확률분포라는 점만 제외하면 일반적인 엔트로피와 같다. 모든 경우에 대해 골고루 확률이 분포되어 있으면 엔트로피값이 커지고 특정한 한 가지 경우에 대해 확률이 모여있으면 엔트로피가 0에 가까워진다.</li>
</ul>
<h3 id="조건부-엔트로피"><a href="#조건부-엔트로피" class="headerlink" title="조건부 엔트로피"></a>조건부 엔트로피</h3><ul>
<li>조건부 엔트로피(conditional entropy)는 어떤 확률 변수 $X$가 다른 확률변수 $Y$의 값을 예측하는데 도움이 되는지를 측정하는 방법 중의 하나이다. 만약 확률변수 X의 값이 어떤 특정한 하나의 값을 가질 때 확률변수 $Y$도 마찬가지로 특정한 값이 된다면 $X$로 $Y$를 예측할 수 있다. 반대로 확률변수 $X$의 값이 어떤 특정한 하나의 값을 가져도 확률변수 $Y$가 여러 값으로 골고루 분포되어 있다면 $X$는 $Y$의 값을 예측하는데 도움이 안된다.</li>
</ul>
<ul>
<li>조건부 엔트로피의 정의는 다음과 같이 유도한다. 확률변수 $X,\;Y$가 모두 이산확률변수라고 가정하고 $X$가 특정한 값 $x_{i]}$를 가질 떄의 $Y$의 엔트로피 $H[Y \mid X=x_i]$는 다음처럼 조건부확률분포의 엔트로피로 정의한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y \mid X=x_i] = - \sum_{j=1}^{K_Y} p(y_j \mid x_i)  \log_2 p(y_j \mid x_i) \end{align}</script><ul>
<li>조건부 엔트로피는 확률변수 $X$가 가질 수 있는 모든 경우에 대해 $H[Y \mid X=x_i]$를 가중평균한 값으로 정의한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y \mid X] &= \sum_{i=1}^{K_X} \,p(x_i)\,H[Y \mid X=x_i]  \\ &= - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} p(y_j \mid x_i)p(x_i)  \log_2 p(y_j \mid x_i)  \\ &= - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} p(x_i, y_j)  \log_2 p(y_j \mid x_i)  \\ \end{align}</script><ul>
<li>연속확률변수의 경우에는 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y \mid X=x] = - \int_{y} p(y \mid x)  \log_2 p(y \mid x)\; dy \end{align}</script><script type="math/tex; mode=display">\begin{align} H[Y \mid X] &= - \int_{x} \,p(x) \,H[Y \mid X=x] \; dx \\ &= - \int_{x} p(x) \left( \int_{y} p(y \mid x)  \log_2 p(y \mid x)\; dy \right) \; dx   \\ &= - \int_{x} \int_{y} p(y \mid x_i) p(x) \log_2 p(y \mid x) \; dxdy \\ &= - \int_{x} \int_{y} \,p(x, y) \log_2 p(y \mid x) \; dxdy \\ \end{align}</script><ul>
<li>따라서 조건부엔트로피의 최종적인 수학적 정의는 다음과 같다.</li>
</ul>
<ul>
<li>이산확률변수의 경우에는 다음과 같이 정의한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y \mid X] = - \sum_{i=1}^{K_X} \sum_{j=1}^{K_Y} \,p(x_i, y_j) \log_2 p(y_j \mid x_i) \end{align}</script><ul>
<li>연속확률변수의 경우에는 다음과 같이 정의한다.</li>
</ul>
<script type="math/tex; mode=display">\begin{align} H[Y \mid X] = - \int_{x} \int_{y} \,p(x, y) \log_2 p(y \mid x)  \; dxdy \end{align}</script><ul>
<li>다시 돌아와 Decision Tree를 이야기하자면 Decision Tree의 일반적인 알고리즘은 데이터 세트를 분할하는 데 가장 좋은 조건, 즉 Information Gain이나 Gini coefficient가 높은 조건을 찾아서 자식 트리 노등에 걸쳐 반복적으로 분할한 뒤, 데이터가 모두 특정 분류에 속하게 되면 분할을 멈추고 분류를 결정한다.</li>
</ul>
<p><img src="/image/how_to_calculate_information_gain_01.png" alt="Information gain 계산 방법"></p>
<p><img src="/image/how_to_calculate_information_gain.png" alt="Information gatin 계산 예시"></p>
<p><img src="/image/Decision_tree_using_information_gain.png" alt="Inforamtion gain을 이용한 Decision Tree 분류"></p>
<p><img src="/image/how_to_split_node_next_step_using_information_gain.png" alt="Decision Tree의 분할과정"></p>
<p><img src="/image/decision_tree_process_cal.png" alt="Decision Tree의 분할"></p>
<h3 id="Information-Gain-예시"><a href="#Information-Gain-예시" class="headerlink" title="Information Gain 예시"></a>Information Gain 예시</h3><p><img src="/image/conditional_entropy_calculate_example.png" alt="정보획득량 예시"></p>
<ul>
<li>예를 들어 A,B 두 가지의 다른 분류 규칙을 적용했더니 위에서 처럼 서로 다르게 데이터가 나뉘어 졌다고 가정하자.</li>
</ul>
<ul>
<li>A방법과 B방법 모두 노드 분리전에는 Y=0인 데이터의 수와 Y=1인 데이터의 수가 모두 40개였다.</li>
</ul>
<ul>
<li>A방법으로 노드를 분리하면 다음과 같은 두 개의 자식 노드가 생긴다.<ul>
<li>자식 노드 A1은 Y=0인 데이터가 30개, Y=1인 데이터가 10개</li>
<li>자식 노드 A2은 Y=0인 데이터가 10개, Y=1인 데이터가 30개</li>
</ul>
</li>
</ul>
<ul>
<li>B방법으로 노드를 분리하면 다음과 같은 두 개의 자식 노드가 생긴다.<ul>
<li>자식 노드 B1은 Y=0인 데이터가 20개, Y=1인 데이터가 40개</li>
<li>자식 노드 B2은 Y=0인 데이터가 20개, Y=1인 데이터가 30개</li>
</ul>
</li>
</ul>
<ul>
<li>우선 부모 노드의 엔트로피를 계산하면 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">H[Y] = -\dfrac{1}{2}\log_2\left(\dfrac{1}{2}\right) -\dfrac{1}{2}\log_2\left(\dfrac{1}{2}\right) = \dfrac{1}{2} + \dfrac{1}{2}  = 1</script><ul>
<li>A 방법에 대해 IG를 계산하면 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">H[Y|X=X_1] = -\dfrac{3}{4}\log_2\left(\dfrac{3}{4}\right) -\dfrac{1}{4}\log_2\left(\dfrac{1}{4}\right) = 0.81</script><script type="math/tex; mode=display">H[Y|X=X_2] = -\dfrac{1}{4}\log_2\left(\dfrac{1}{4}\right)  -\dfrac{3}{4}\log_2\left(\dfrac{3}{4}\right) = 0.81</script><script type="math/tex; mode=display">H[Y|X] = \dfrac{1}{2} H[Y|X=X_1] + \dfrac{1}{2} H[Y|X=X_2] = 0.81</script><script type="math/tex; mode=display">IG = H[Y] - H[Y|X] = 0.19</script><ul>
<li>B 방법에 대해 IG를 계산하면 다음과 같다.</li>
</ul>
<script type="math/tex; mode=display">H[Y|X=X_1] = -\dfrac{1}{3}\log_2\left(\dfrac{1}{3}\right) - \dfrac{2}{3}\log_2\left(\dfrac{2}{3}\right) = 0.92</script><script type="math/tex; mode=display">H[Y|X=X_2] = 0</script><script type="math/tex; mode=display">H[Y|X] = \dfrac{3}{4} H[Y|X=X_1] + \dfrac{1}{4} H[Y|X=X_2] = 0.69</script><script type="math/tex; mode=display">IG = H[D] - H[Y|X] = 0.31</script><ul>
<li><code>따라서 B 방법이 더 나은 방법임을 알 수 있다.</code></li>
</ul>
<ul>
<li>위와 같이 model을 fitting하였으면, 이제 어떻게 해당 영역에 예측할 데이터가 포함된다면 어떻게 클래스를 정하는지에 대해서 알아볼 것이다. 간단히 말하자면 해당 영역에 포함된 클래스의 개수가 많은 것으로 예측한다.</li>
</ul>
<p><img src="/image/how_to_precidct_data_class_01.png" alt="Decision tree의 predict - 01"></p>
<p><img src="/image/how_to_precidct_data_class_02.png" alt="Decision tree의 predict - 01"></p>
<p><img src="/image/how_to_precidct_data_class_03.png" alt="Decision tree의 predict - 01"></p>
<h3 id="Decision-Tree의-특징"><a href="#Decision-Tree의-특징" class="headerlink" title="Decision Tree의 특징"></a>Decision Tree의 특징</h3><ul>
<li>결정 트리의 가장 큰 장점은 정보의 균일도라는 률을 기반으로 하고 있어서 <code>알고리즘이 쉽고 직관적</code>이라는 점이다. 결정 트리가 룰이 매우 명확하고, 이에 기반해 어떻게 규칙 노드와 리프 노드가 만들어지는지 알 수 있고, 시각화로 표현까지 할 수 있다. <code>또한 정보의 균일도만 신경쓰면 되므로 특별한 경우를 제외하고는 각 feature의 스케일링과 normalization과 같은 작업이 크게 영향을 미치지 않는다.</code> 반면에 결정 트리 모델의 가장 큰 단점은 <code>과적합(overfitting)으로 정확도가 떨어진다는 점</code>이다. 복잡한 학습 모델은 결국에는 실제 상황(테스트 데이터)에 유연하게 대처할 수 없어서 예측 성능이 떨어질 수 밖에 없다. <code>트리의 크기를 사전에 제한하는 것이 오히려 성능 튜닝에 더 도움이 될 것</code>이다.</li>
</ul>
<h3 id="Scikit-Learn의-의사결정나무-클래스"><a href="#Scikit-Learn의-의사결정나무-클래스" class="headerlink" title="Scikit-Learn의 의사결정나무 클래스"></a>Scikit-Learn의 의사결정나무 클래스</h3><h2 id="Scikit-Learn에서-의사결정나무는-DecisionTreeClassifier클래스로-구현되어있다-여기에서는-붓꽃-분류-문제를-예를-들어-의사결정나무를-설명한다-이-예제에서는-독립변수-공간을-공간상에-표시하기-위해-꽃의-길이와-폭만을-독립변수로-사용하였다"><a href="#Scikit-Learn에서-의사결정나무는-DecisionTreeClassifier클래스로-구현되어있다-여기에서는-붓꽃-분류-문제를-예를-들어-의사결정나무를-설명한다-이-예제에서는-독립변수-공간을-공간상에-표시하기-위해-꽃의-길이와-폭만을-독립변수로-사용하였다" class="headerlink" title="- Scikit-Learn에서 의사결정나무는 DecisionTreeClassifier클래스로 구현되어있다. 여기에서는 붓꽃 분류 문제를 예를 들어 의사결정나무를 설명한다. 이 예제에서는 독립변수 공간을 공간상에 표시하기 위해 꽃의 길이와 폭만을 독립변수로 사용하였다."></a>- Scikit-Learn에서 의사결정나무는 <code>DecisionTreeClassifier</code>클래스로 구현되어있다. 여기에서는 붓꽃 분류 문제를 예를 들어 의사결정나무를 설명한다. 이 예제에서는 독립변수 공간을 공간상에 표시하기 위해 꽃의 길이와 폭만을 독립변수로 사용하였다.</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"></span><br><span class="line">data = load_iris()</span><br><span class="line">y = data.target</span><br><span class="line">X = data.data[:, 2:]</span><br><span class="line">feature_names = data.feature_names[2:]</span><br><span class="line"></span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">tree1 = DecisionTreeClassifier(criterion=<span class="string">'entropy'</span>, max_depth=1, random_state=0).fit(X, y)</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>다음은 의사결정나무를 시각화하기 위한 코드이다. <code>draw_decision_tree</code>함수는 의사결정나무의 의사 결정 과정의 세부적인 내역을 다이어그램으로 보여주고 <code>plot_decision_regions</code>함수는 이러한 의사 결정에 의해 데이터의 영역이 어떻게 나뉘어졌는지를 시각화하여 보여준다.</li>
</ul>
<ul>
<li>아래 방법으로 draw_decision_tree함수를 동일하게 출력할 수 있다.<ul>
<li><code>filled</code>: 그래프에 각 클래스별로 색상을 입힘.</li>
<li><code>rounded</code>: 반올림 시켜주는 역할</li>
<li><code>special_characters</code>: 특수문자가 있을 경우 제외시켜줌.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dot_data=tree.export_graphviz(out_file=None, decision_tree=tree1,feature_names=iris.feature_names,</span><br><span class="line">                             class_names=iris.target_names,</span><br><span class="line">                             filled=True, rounded=True, special_characters=True)</span><br><span class="line">graphviz.Source(dot_data)</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import io</span><br><span class="line">import pydot</span><br><span class="line">from IPython.core.display import Image</span><br><span class="line">from sklearn.tree import export_graphviz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def draw_decision_tree(model):</span><br><span class="line">    dot_buf = io.StringIO()</span><br><span class="line">    export_graphviz(model, out_file=dot_buf, feature_names=feature_names)</span><br><span class="line">    graph = pydot.graph_from_dot_data(dot_buf.getvalue())[0]</span><br><span class="line">    image = graph.create_png()</span><br><span class="line">    <span class="built_in">return</span> Image(image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def plot_decision_regions(X, y, model, title):</span><br><span class="line">    resolution = 0.01</span><br><span class="line">    markers = (<span class="string">'s'</span>, <span class="string">'^'</span>, <span class="string">'o'</span>)</span><br><span class="line">    colors = (<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'lightgreen'</span>)</span><br><span class="line">    cmap = mpl.colors.ListedColormap(colors)</span><br><span class="line"></span><br><span class="line">    x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1</span><br><span class="line">    x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1</span><br><span class="line">    xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),</span><br><span class="line">                           np.arange(x2_min, x2_max, resolution))</span><br><span class="line">    Z = model.predict(</span><br><span class="line">        np.array([xx1.ravel(), xx2.ravel()]).T).reshape(xx1.shape)</span><br><span class="line"></span><br><span class="line">    plt.contour(xx1, xx2, Z, cmap=mpl.colors.ListedColormap([<span class="string">'k'</span>]))</span><br><span class="line">    plt.contourf(xx1, xx2, Z, alpha=0.4, cmap=cmap)</span><br><span class="line">    plt.xlim(xx1.min(), xx1.max())</span><br><span class="line">    plt.ylim(xx2.min(), xx2.max())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, cl <span class="keyword">in</span> enumerate(np.unique(y)):</span><br><span class="line">        plt.scatter(x=X[y == cl, 0], y=X[y == cl, 1], alpha=0.8,</span><br><span class="line">                    c=[cmap(idx)], marker=markers[idx], s=80, label=cl)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(data.feature_names[2])</span><br><span class="line">    plt.ylabel(data.feature_names[3])</span><br><span class="line">    plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">    plt.title(title)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> Z</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_decision_tree(tree1)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id><a href="#" class="headerlink" title></a><img src="/image/iris_data_first_divide_on_plot_01.png" alt="max_depth=1인 경우의 decision tree의 분할 - 01"></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_decision_regions(X, y, tree1, <span class="string">"Depth 1"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="/image/iris_data_first_divide_on_plot_02.png" alt="max_depth=1인 경우의 decision tree의 분할 - 02"></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line"></span><br><span class="line">confusion_matrix(y, tree1.predict(X))</span><br></pre></td></tr></table></figure>
<h5 id="결과-16"><a href="#결과-16" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[50,  0,  0],</span><br><span class="line">       [ 0, 50,  0],</span><br><span class="line">       [ 0, 50,  0]])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="depth-2로-변경한-후의-결과"><a href="#depth-2로-변경한-후의-결과" class="headerlink" title="- depth=2로 변경한 후의 결과"></a>- depth=2로 변경한 후의 결과</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree2 = DecisionTreeClassifier(</span><br><span class="line">    criterion=<span class="string">'entropy'</span>, max_depth=2, random_state=0).fit(X, y)</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_decision_tree(tree2)</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_03.png" alt="max_depth=2로 한 후의 분할 - 01"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_decision_regions(X, y, tree2, <span class="string">"Depth 2"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_04.png" alt="max_depth=2로 한 후의 분할 - 02"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confusion_matrix(y, tree2.predict(X))</span><br></pre></td></tr></table></figure>
<h5 id="결과-17"><a href="#결과-17" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[50,  0,  0],</span><br><span class="line">       [ 0, 49,  1],</span><br><span class="line">       [ 0,  5, 45]])</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>max_depth=3으로 변경한 후의 결과</li>
</ul>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree3 = DecisionTreeClassifier(</span><br><span class="line">    criterion=<span class="string">'entropy'</span>, max_depth=3, random_state=0).fit(X, y)</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_decision_tree(tree3)</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_05.png" alt="max_depth=3로 한 후의 분할 - 01"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_decision_regions(X, y, tree3, <span class="string">"Depth 3"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_06.png" alt="max_depth=3로 한 후의 분할 - 01"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confusion_matrix(y, tree3.predict(X))</span><br></pre></td></tr></table></figure>
<h5 id="결과-18"><a href="#결과-18" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[50,  0,  0],</span><br><span class="line">       [ 0, 47,  3],</span><br><span class="line">       [ 0,  1, 49]])</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>max_depth=5로 변경한 후 결과</li>
</ul>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree5 = DecisionTreeClassifier(</span><br><span class="line">    criterion=<span class="string">'entropy'</span>, max_depth=5, random_state=0).fit(X, y)</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_decision_tree(tree5)</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_07.png" alt="max_depth=5로 한 후의 분할 - 01"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_decision_regions(X, y, tree5, <span class="string">"Depth 5"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/image/iris_data_first_divide_on_plot_08.png" alt="max_depth=5로 한 후의 분할 - 02"></p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confusion_matrix(y, tree5.predict(X))</span><br></pre></td></tr></table></figure>
<h5 id="결과-19"><a href="#결과-19" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[50,  0,  0],</span><br><span class="line">       [ 0, 49,  1],</span><br><span class="line">       [ 0,  0, 50]])</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(classification_report(y, tree5.predict(X)))</span><br></pre></td></tr></table></figure>
<h5 id="결과-20"><a href="#결과-20" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">           0       1.00      1.00      1.00        50</span><br><span class="line">           1       1.00      0.98      0.99        50</span><br><span class="line">           2       0.98      1.00      0.99        50</span><br><span class="line"></span><br><span class="line">    accuracy                           0.99       150</span><br><span class="line">   macro avg       0.99      0.99      0.99       150</span><br><span class="line">weighted avg       0.99      0.99      0.99       150</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>교차검증을 통해 최종모형의 성능을 살펴보면 아래와 같다.</li>
</ul>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import KFold, cross_val_score</span><br><span class="line"></span><br><span class="line">cv = KFold(5, shuffle=True, random_state=0)</span><br><span class="line">model = DecisionTreeClassifier(criterion=<span class="string">'entropy'</span>, max_depth=5,</span><br><span class="line">                               random_state=0)</span><br><span class="line">cross_val_score(model, X, y, scoring=<span class="string">"accuracy"</span>, cv=cv).mean()</span><br></pre></td></tr></table></figure>
<h5 id="결과-21"><a href="#결과-21" class="headerlink" title="결과"></a>결과</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.9466666666666667</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Regression-tree"><a href="#Regression-tree" class="headerlink" title="Regression tree"></a>Regression tree</h3><ul>
<li>regression tree는 종속변수가 연속형인 것만 제외했을땐 아래에서 보는 것과 같이 동일한 개념을 가진다.</li>
</ul>
<p><img src="/image/Regression_Tree_concept_01.png" alt="Regression Tree의 개념"></p>
<ul>
<li>Regression Tree는 <code>예측시에 각각의 영역에 대해 특정 실수값을 주는 방식</code>이다. 아래 수식에서 $c_{m}$은 오른쪽 그림에서와 같이 해당 영역의 높이라고 할 수 있다.</li>
</ul>
<p><img src="/image/Regression_Tree_concept_02.png" alt="Regression Tree 시각적으로 이해하기"></p>
<ul>
<li>classification의 경우에는 entropy로 정했지만, Regression의 경우에는 아래 2번째 수식에서 볼 수 있듯이 기본적인 회귀의 성능지표를 사용하여 변수를 선택하게 된다.</li>
</ul>
<p><img src="/image/Regression_Tree_concept_03.png" alt="Regression Tree 변수 선택방법"></p>
<ul>
<li>이렇게 결정된 영역에 속하는 예측값은 해당 영역의 평균값을 출력해주며, 영역별로(층별로) 존재한다.</li>
</ul>
<p><img src="/image/Regression_Tree_concept_04.png" alt="Regression Tree 예측"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">rng = np.random.RandomState(1)</span><br><span class="line">X = np.sort(5 * rng.rand(80, 1), axis=0)</span><br><span class="line">y = np.sin(X).ravel()</span><br><span class="line">y[::5] += 3 * (0.5 - rng.rand(16))</span><br><span class="line"></span><br><span class="line">regtree = DecisionTreeRegressor(max_depth=3)</span><br><span class="line">regtree.fit(X, y)</span><br><span class="line"></span><br><span class="line">X_test = np.arange(0.0, 5.0, 0.01)[:, np.newaxis]</span><br><span class="line">y_hat = regtree.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the results</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, s=20, edgecolor=<span class="string">"black"</span>, c=<span class="string">"darkorange"</span>, label=<span class="string">"데이터"</span>)</span><br><span class="line">plt.plot(X_test, y_hat, color=<span class="string">"cornflowerblue"</span>, linewidth=2, label=<span class="string">"예측"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x"</span>)</span><br><span class="line">plt.ylabel(r<span class="string">"<span class="variable">$y</span>$ &amp; $\hat&#123;y&#125;$"</span>)</span><br><span class="line">plt.title(<span class="string">"회귀 나무"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/image/Regression_tree_plot.png" alt="회귀나무"></p>

        </div>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 하단형 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4604833066889492"
     data-ad-slot="9861011486"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        <footer class="article-footer">
            


    <div class="a2a_kit a2a_default_style">
    <a class="a2a_dd" href="https://www.addtoany.com/share">Share</a>
    <span class="a2a_divider"></span>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_pinterest"></a>
    <a class="a2a_button_tumblr"></a>
</div>
<script type="text/javascript" src="//static.addtoany.com/menu/page.js"></script>
<style>
    .a2a_menu {
        border-radius: 4px;
    }
    .a2a_menu a {
        margin: 2px 0;
        font-size: 14px;
        line-height: 16px;
        border-radius: 4px;
        color: inherit !important;
        font-family: 'Microsoft Yahei';
    }
    #a2apage_dropdown {
        margin: 10px 0;
    }
    .a2a_mini_services {
        padding: 10px;
    }
    a.a2a_i,
    i.a2a_i {
        width: 122px;
        line-height: 16px;
    }
    a.a2a_i .a2a_svg,
    a.a2a_more .a2a_svg {
        width: 16px;
        height: 16px;
        line-height: 16px;
        vertical-align: top;
        background-size: 16px;
    }
    a.a2a_i {
        border: none !important;
    }
    a.a2a_menu_show_more_less {
        margin: 0;
        padding: 10px 0;
        line-height: 16px;
    }
    .a2a_mini_services:after{content:".";display:block;height:0;clear:both;visibility:hidden}
    .a2a_mini_services{*+height:1%;}
</style>


        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "HeungBae Lee"
        },
        "headline": "의사결정나무",
        "image": "https://heung-bae-lee.github.io/image/decision_tree_concept.png",
        "keywords": "",
        "genre": "machine learning",
        "datePublished": "2020-04-26",
        "dateCreated": "2020-04-26",
        "dateModified": "2020-04-30",
        "url": "https://heung-bae-lee.github.io/2020/04/26/machine_learning_13/",
        "description": "Decision tree 배경
의사결정나무의 장점은 해석력이 좋다. 우리가 모델을 만들때 성능이 좋은 것도 중요하지만, 어떻게 사람들한테 메세지를 줄 수 있는가처럼 어떻게 활용할 수 있는가가 더 중요한 경우도 있다. 예측력이 조금 떨어지더라도 이야기로 풀어서 어떠한 근거로 인해 Y는 이렇게 된다는 식으로 풀어서 설명할 수 있다는 의미이다.


결정트리는 매"
        "wordCount": 4928
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://www.facebook.com/heungbae.lee" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/HEUNG-BAE-LEE" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2020/04/27/data_structure_02/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            내가 정리하는 자료구조 01 Stack
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2020/04/25/machine_learning_12/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">Support Vector Machine(SVM) - 02</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/machine-learning/">machine learning</a></p>
                            <p class="item-title"><a href="/2020/05/27/machine_learning_16/" class="title">Ensemble Learning - Ensemble의 Ensemble</a></p>
                            <p class="item-date"><time datetime="2020-05-26T17:04:18.000Z" itemprop="datePublished">2020-05-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/machine-learning/">machine learning</a></p>
                            <p class="item-title"><a href="/2020/05/27/machine_learning_15/" class="title">Ensemble Learning - Boosting, Stacking</a></p>
                            <p class="item-date"><time datetime="2020-05-26T17:00:49.000Z" itemprop="datePublished">2020-05-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2020/05/17/data_structure_07/" class="title">내가 정리하는 자료구조 06 - 힙(heap)</a></p>
                            <p class="item-date"><time datetime="2020-05-17T14:39:31.000Z" itemprop="datePublished">2020-05-17</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/linear-algebra/">linear algebra</a></p>
                            <p class="item-title"><a href="/2020/05/14/linear_algebra_03/" class="title">Linear combination, vector equation, Four views of matrix multiplication</a></p>
                            <p class="item-date"><time datetime="2020-05-14T06:36:03.000Z" itemprop="datePublished">2020-05-14</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/linear-algebra/">linear algebra</a></p>
                            <p class="item-title"><a href="/2020/05/13/linear_algebra_02/" class="title">선형 시스템(Linear system)</a></p>
                            <p class="item-date"><time datetime="2020-05-13T07:50:33.000Z" itemprop="datePublished">2020-05-13</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Bayes/">Bayes</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-자료구조/">C/C++/자료구조</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS231n/">CS231n</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Front-end/">Front end</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kaggle/">Kaggle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Recommendation-System/">Recommendation System</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Statistics-Mathematical-Statistics/">Statistics - Mathematical Statistics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/crawling/">crawling</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data-engineering/">data engineering</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/deep-learning/">deep learning</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/growth-hacking/">growth hacking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linear-algebra/">linear algebra</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/machine-learning/">machine learning</a><span class="category-list-count">17</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS231n/">CS231n</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawling/">crawling</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/CS231n/" style="font-size: 10px;">CS231n</a> <a href="/tags/crawling/" style="font-size: 20px;">crawling</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 사이드바 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4604833066889492"
     data-ad-slot="3275421833"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2020 HeungBae Lee</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://heung-bae-lee.github.io/2020/04/26/machine_learning_13/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>
</html>
